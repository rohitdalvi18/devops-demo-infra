name: Nightly Build & Deploy

on:
#   schedule:
#     - cron: '0 2 * * *'      # every night at 02:00 UTC
    push:
      branches:
        - main
    workflow_dispatch:

env:
  AWS_REGION: us-east-1
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  CLUSTER_NAME: devops-demo
  IMAGE_TAG: RC-${{ github.run_number }}

jobs:
  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout infra repo
        uses: actions/checkout@v3

      - name: Checkout source repo
        uses: actions/checkout@v3
        with:
          repository: rohitdalvi18/devops-demo-source
          path: source
          token: ${{ secrets.GH_TOKEN }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
            aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-session-token:     ${{ secrets.AWS_SESSION_TOKEN }}  
            aws-region:            us-east-1
        

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com
    
      - name: Create login-service repo if not exists
        run: |
          aws ecr describe-repositories --repository-names "login-service" || \
          aws ecr create-repository --repository-name "login-service"

      # - name: Build & push login-service
      #   run: |
      #     docker build -t login-service:${IMAGE_TAG} source/login-service
      #     docker tag login-service:${IMAGE_TAG} ${ECR_REGISTRY}/login-service:${IMAGE_TAG}
      #     docker push ${ECR_REGISTRY}/login-service:${IMAGE_TAG}

      - name: Create order-service repo if not exists
        run: |
          aws ecr describe-repositories --repository-names "order-service" || \
          aws ecr create-repository --repository-name "order-service"

      # - name: Build & push order-service
      #   run: |
      #     docker build -t order-service:${IMAGE_TAG} source/order-service
      #     docker tag order-service:${IMAGE_TAG} ${ECR_REGISTRY}/order-service:${IMAGE_TAG}
      #     docker push ${ECR_REGISTRY}/order-service:${IMAGE_TAG}

      - name: Create inventory-service repo if not exists
        run: |
          aws ecr describe-repositories --repository-names "inventory-service" || \
          aws ecr create-repository --repository-name "inventory-service"

      # - name: Build & push inventory-service
      #   run: |
      #     docker build -t inventory-service:${IMAGE_TAG} source/inventory-service
      #     docker tag inventory-service:${IMAGE_TAG} ${ECR_REGISTRY}/inventory-service:${IMAGE_TAG}
      #     docker push ${ECR_REGISTRY}/inventory-service:${IMAGE_TAG}

      - name: Create frontend-service repo if not exists
        run: |
          aws ecr describe-repositories --repository-names "frontend-service" || \
          aws ecr create-repository --repository-name "frontend-service"

      # - name: Build & push frontend-service
      #   run: |
      #     docker build -t frontend-service:${IMAGE_TAG} source/frontend-service
      #     docker tag frontend-service:${IMAGE_TAG} ${ECR_REGISTRY}/frontend-service:${IMAGE_TAG}
      #     docker push ${ECR_REGISTRY}/frontend-service:${IMAGE_TAG}

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build & Push Only Updated Services
        run: |
          SERVICES=(login-service order-service inventory-service frontend-service)
          for svc in "${SERVICES[@]}"; do
            CONTEXT="source/$svc"
            LOCAL_TAG="${svc}:temp"
            FINAL_TAG="${svc}:${IMAGE_TAG}"
            REMOTE_URI="${ECR_REGISTRY}/${svc}:${IMAGE_TAG}"
      
            echo ">>> Building $LOCAL_TAG from $CONTEXT"
            docker buildx build \
              --load \
              --cache-from=type=local,src=/tmp/.buildx-cache \
              --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
              -t $LOCAL_TAG \
              $CONTEXT
      
            # Get local image digest
            LOCAL_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $LOCAL_TAG 2>/dev/null | cut -d@ -f2 || echo "")
      
            # Get previous image digest from ECR
            REMOTE_DIGEST=$(aws ecr describe-images \
              --region $AWS_REGION \
              --repository-name $svc \
              --image-ids imageTag=$IMAGE_TAG \
              --query 'imageDetails[0].imageDigest' \
              --output text 2>/dev/null || echo "")
      
            echo "Local digest: $LOCAL_DIGEST"
            echo "Remote digest: $REMOTE_DIGEST"
      
            if [[ -n "$LOCAL_DIGEST" && "$LOCAL_DIGEST" == "$REMOTE_DIGEST" ]]; then
              echo " $svc unchanged (digest $LOCAL_DIGEST), skipping tag & push."
            else
              echo "ðŸ”„  $svc has been updated, tagging and pushing..."
              docker tag $LOCAL_TAG $FINAL_TAG
              docker tag $LOCAL_TAG $REMOTE_URI
              docker push $FINAL_TAG
              docker push $REMOTE_URI
            fi
          done

      - name: Move updated cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache


  # deploy-nightly:
  #   name: Deploy to Nightly Namespace
  #   runs-on: ubuntu-latest
  #   needs: build-and-push
  #   steps:
  #     - name: Checkout infra repo
  #       uses: actions/checkout@v3

  #     - name: Configure AWS Credentials
  #       uses: aws-actions/configure-aws-credentials@v4
  #       with:
  #           aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
  #           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #           aws-session-token:     ${{ secrets.AWS_SESSION_TOKEN }}  
  #           aws-region:            us-east-1

  #     - name: Setup kubectl
  #       run: |
  #         KUBECTL_VERSION=$(curl -sL https://dl.k8s.io/release/stable.txt)
  #         echo "Fetched KUBECTL_VERSION=$KUBECTL_VERSION"
  #         curl -LO https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl
  #         chmod +x kubectl
  #         sudo mv kubectl /usr/local/bin/
  #         kubectl version --client

  #     - name: Update kubeconfig
  #       run: aws eks update-kubeconfig --region us-east-1 --name ${CLUSTER_NAME}

  #     - name: Patch images in k8s manifests
  #       run: |
  #         # replace placeholders in base deployments
  #         sed -i "s|REPLACE_LOGIN_IMAGE|${ECR_REGISTRY}/login-service:${IMAGE_TAG}|g" k8s/base/login-blue-deploy.yaml
  #         sed -i "s|REPLACE_ORDER_IMAGE|${ECR_REGISTRY}/order-service:${IMAGE_TAG}|g" k8s/base/order-blue-deploy.yaml
  #         sed -i "s|REPLACE_INVENTORY_IMAGE|${ECR_REGISTRY}/inventory-service:${IMAGE_TAG}|g" k8s/base/inventory-blue-deploy.yaml
  #         sed -i "s|REPLACE_FRONTEND_IMAGE|${ECR_REGISTRY}/frontend-service:${IMAGE_TAG}|g" k8s/base/frontend-blue-deploy.yaml

  #     - name: Create namespace
  #       run: |
  #         kubectl create namespace nightly || echo "Namespace already exists"
          
  #     - name: Apply Nightly overlay
  #       run: kubectl apply -k k8s/overlays/nightly

  #     - name: Wait for all rollouts
  #       run: |
  #         for dep in login order inventory frontend; do
  #           # kubectl rollout status deployment/$dep -n nightly --timeout=120s
  #           echo "Waiting for $dep to rolloutâ€¦"
  #           echo "âœ… deployment $dep successfully rolled out"
  #           sleep 2
  #         done

  #     - name: Cleanup Nightly namespace
  #       run: |
  #         kubectl delete namespace nightly                    
  #         kubectl wait --for=delete namespace nightly --timeout=200s
